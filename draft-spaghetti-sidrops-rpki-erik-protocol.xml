<?xml version='1.0' encoding='UTF-8'?>

<!DOCTYPE rfc [
 <!ENTITY nbsp    "&#160;">
 <!ENTITY zwsp   "&#8203;">
 <!ENTITY nbhy   "&#8209;">
 <!ENTITY wj     "&#8288;">
]>

<rfc xmlns:xi="http://www.w3.org/2001/XInclude"
category="std"
docName="draft-spaghetti-sidrops-rpki-erik-protocol-04"
ipr="trust200902"
xml:lang="en"
sortRefs="true"
submissionType="IETF"
consensus="true"
symRefs="true"
tocInclude="true"
version="3">

  <front>

    <title abbrev="Erik Synchronization Protocol for RPKI">
      The Erik Synchronization Protocol for use with the Resource Public Key Infrastructure (RPKI)
    </title>

    <author fullname="Job Snijders" initials="J." surname="Snijders">
      <organization abbrev="BSD">BSD Software Development</organization>
      <address>
        <postal>
          <postalLine>Amsterdam</postalLine>
          <postalLine>The Netherlands</postalLine>
        </postal>
        <email>job@bsd.nl</email>
        <uri>https://wwww.bsd.nl/</uri>
      </address>
    </author>

    <author fullname="Tim Bruijnzeels" initials="T." surname="Bruijnzeels">
      <organization>RIPE NCC</organization>
      <address>
        <postal>
          <postalLine>The Netherlands</postalLine>
        </postal>
        <email>tim@ripe.net</email>
      </address>
    </author>

    <author fullname="Tom Harrison" initials="T." surname="Harrison">
      <organization>APNIC</organization>
      <address>
        <postal>
          <country>AU</country>
        </postal>
        <email>tomh@apnic.net</email>
      </address>
    </author>

    <author fullname="Wataru Ohgai" initials="W." surname="Ohgai">
      <organization>JPNIC</organization>
      <address>
        <postal>
          <country>JP</country>
        </postal>
        <email>alt@nic.ad.jp</email>
      </address>
    </author>

    <date/>

   <area>Operations and Management Area (OPS)</area>
   <workgroup>SIDROPS</workgroup>

   <keyword>Data synchronization</keyword>

    <abstract>
      <t>
        This document specifies the Erik Synchronization Protocol for use with the Resource Public Key Infrastructure (RPKI).
        Erik Synchronization can be characterized as a data replication system using Merkle trees, a content-addressable naming scheme, concurrency control using monotonically increasing sequence numbers, and HTTP transport.
        Relying Parties can combine information retrieved via Erik Synchronization with other RPKI transport protocols.
        The protocol's design is intended to be efficient, fast, easy to implement, and robust in the face of partitions or faults in the network.
      </t>
    </abstract>

  </front>

  <middle>

    <section anchor="intro">
      <name>Introduction</name>
      <t>
        This document specifies the Erik Synchronization Protocol for use with the Resource Public Key Infrastructure (RPKI) <xref target="RFC6480"/>.
        Erik Synchronization can be characterized as a data replication system using Merkle trees <xref target="M1987"/>, a content-addressable naming scheme <xref target="RFC6920"/>, concurrency control using monotonically increasing sequence numbers <xref target="RFC0677"/>, and HTTP transport <xref target="RFC9110"/>.
        Relying Parties can combine information retrieved via Erik Synchronization with other RPKI transport protocols (<xref target="RFC5781"/> and <xref target="RFC8182"/>).
        The protocol's design is intended to be efficient, fast, easy to implement <xref target="RFC1925"/>, and robust in the face of partitions or faults in the network.
      </t>

      <section>
        <name>Background</name>
        <t>
          The notion of cache-to-cache data replication of unvalidated data was documented in <xref target="RFC7115" section="3"/>.
        </t>
        <blockquote quotedFrom="RFC7115, section 3">
          <t>
             Validated caches may also be created and maintained from other validated caches.
             Network operators SHOULD take maximum advantage of this feature to minimize load on the global distributed RPKI database.
             Of course, the recipient relying parties should re-validate the data.
          </t>
        </blockquote>

        <t>
          Historic records show that experiments have been performed in this space using, for example, peer-to-peer file sharing technology (see <xref target="P2P"/>), but no standardised and widely-deployed mechanism for cache-to-cache replication emerged since then.
          The authors hope that the Erik Synchronization protocol might be suitable to fill this gap and improve propagation speed of validly signed repository data as well as help reduce load on the global RPKI.
        </t>
      </section>

      <section anchor="reqs-lang">
        <name>Requirements Language</name>
        <t>
          The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>", "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL NOT</bcp14>", "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>", "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>", "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are to be interpreted as described in BCP&nbsp;14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they appear in all capitals, as shown here.</t>
      </section>

      <section anchor="Related">
        <name>Related Work</name>
        <t>
          The reader is assumed to be familiar with the terms and concepts described in
          "<xref target="RFC0677" format="title"/>" <xref target="RFC0677" format="default"/>,
          "<xref target="RFC6480" format="title"/>" <xref target="RFC6480" format="default"/>,
          "<xref target="RFC8182" format="title"/>" <xref target="RFC8182" format="default"/>,
          "<xref target="RFC9286" format="title"/>" <xref target="RFC9286" format="default"/>,
          "<xref target="M1987" format="title"/>" <xref target="M1987" format="default"/>.
        </t>
      </section>


      <section anchor="glossary">
        <name>Glossary</name>
        <t>
          This section describes the terminology and abbreviations used in this document.
          Though the definitions might not be clear on a first read, later on the terms will be introduce with more detail.
        </t>

        <dl>

           <dt>Erik relay</dt>
           <dd>An intermediate between CA publication repositories and Relying Parties.</dd>

           <dt>FQDN</dt>
           <dd>The fully qualified domain name of a RPKI repository instance referenced in an end-entity certificate's Subject Information Access (SIA) extension's id-ad-signedObject accessDescription.</dd>

           <dt>Hash</dt>
           <dd>A message digest calculated for an object using the SHA-256 algorithm.</dd>

           <dt>ErikIndex</dt>
           <dd>The relay's Merkle root for a given FQDN. An ErikIndex is an ordered listing of Partition identifiers and associated ErikPartition objects' hashes.</dd>

           <dt>ErikPartition</dt>
           <dd>An ordered listing of the manifest objects' hashes, manifestNumber values, thisUpdate values, and their certificates' SIA extension values.</dd>

        </dl>
      </section>

    </section>

    <section anchor="overview">
      <name>Informal Overview</name>
      <t>
        Erik Synchronisation is an architecture to reliably distribute RPKI repository data from cache to cache using so-called Erik relays.
        Relays maintain a validated cache themselves and can be clients of other relays.
        While this property suggests that a group of relays should converge to the exact same state, the distributed nature of the RPKI prevents relays from achieving strict synchronization.
      </t>
      <t>
        In this synchronization protocol, Merkle trees are used to determine whether differences exist between client and relay.
        Merkle trees are hierarchical data structures: the hash value of each node is computed recursively by hashing the concatenated hash values of the node's children.
        The hash of the ErikIndex represents the entire dataset related to a given FQDN.
        If the ErikIndex hash is not the same between two replicas, the relay provides the client with hashes of smaller and smaller portions of the to-be-replicated dataset until the exact list of out-of-sync or missing objects is identified.
        Sequence numbers are then used to determine whether these differences are relevant enough for the client to fetch.
        All data, except for ErikIndex objects, is fetched using static addresses derived from object hashes.
        This approach reduces unnecessary data transfer between caches which contain mostly similar data.
      </t>
      <t>
        The client starts by querying an Erik relay for the relay's current ErikIndex for a given FQDN.
        If the ErikIndex is different compared to the previous run (or compared to the Index calculated from the locally cached objects).
        With the ErikIndex in hand, the client can determine which ErikPartition are missing and fetch accordingly.
        The client then can compare the <em>manifestNumber</em> sequence number and <em>thisUpdate</em> for each manifest listed in the ErikPartition, and proceed to fetch (purportedly) newer versions of manifests of interest.
        Whenever a relay has manifests with a lower sequence number on offer, the client can ignore those.
        The client now has sufficient information to proceed to fetch any missing Certificates, Signed objects, and CRLs.
        With the information contained within manifests, clients can fetch addressed by content (by hash) and store by name (or some other scheme).
      </t>
    </section>

    <section anchor="asn1">
      <name>Erik Synchronization Data Structure Definitions</name>
      <t>
        In this synchronization protocol the <em>signal layer</em> makes use of DER-encoded messages <xref target="X.690"/>.
      </t>
      <t>
        <em>Design note: DER encoding was selected for its canonical properties and because RPKI cache implementations already support ASN.1 encoding.</em>
      </t>
<sourcecode type="asn.1" markers="false">
<![CDATA[
RpkiErikSynchronization-2025
  { iso(1) member-body(2) us(840) rsadsi(113549)
    pkcs(1) pkcs9(9) smime(16) mod(0)
    id-mod-rpkiErikSynchronization-2025(TBD) }

DEFINITIONS EXPLICIT TAGS ::=
BEGIN

-- EXPORTS ALL --

IMPORTS
  CONTENT-TYPE, Digest, DigestAlgorithmIdentifier
  FROM CryptographicMessageSyntax-2010 -- in [RFC6268]
  { iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1)
    pkcs-9(9) smime(16) modules(0) id-mod-cms-2009(58) }

  AccessDescription, KeyIdentifier
  FROM PKIX1Implicit88 -- in [RFC5280]
  { iso(1) identified-organization(3) dod(6) internet(1) security(5)
    mechanisms(5) pkix(7) id-mod(0) id-pkix1-implicit(19) }
;

EncapsulatedContentInfo ::= SEQUENCE {
  eContentType     CONTENT-TYPE.&id({ContentSet}),
  eContent         [0] EXPLICIT OCTET STRING
    (CONTAINING CONTENT-TYPE.&Type({ContentSet}{@eContentType})) OPTIONAL }

ContentSet CONTENT-TYPE ::= {
  ct-rpkiErikIndex | ct-rpkiErikPartition, ... }

ct-rpkiErikIndex CONTENT-TYPE ::=
  { TYPE ErikIndex IDENTIFIED BY id-ct-rpkiErikIndex }

id-ct-rpkiErikIndex OBJECT IDENTIFIER ::=
  { iso(1) identified-organization(3) dod(6) internet(1) private(4)
    enterprise(1) snijders(41948) erikindex(826) }

ErikIndex ::= SEQUENCE {
  version [0]      INTEGER DEFAULT 0,
  indexScope       IA5String,
  indexTime        GeneralizedTime,
  hashAlg          DigestAlgorithmIdentifier,
  partitionList    SEQUENCE SIZE (1..ub-Partitions) OF PartitionRef }

ub-Partitions INTEGER ::= 1024

PartitionRef ::= SEQUENCE {
  identifier       INTEGER (1..ub-Partitions),
  hash             Digest,
  size             INTEGER (100..MAX) }

ct-rpkiErikPartition CONTENT-TYPE ::=
  { TYPE ErikPartition IDENTIFIED BY id-ct-rpkiErikPartition }

id-ct-rpkiErikPartition OBJECT IDENTIFIER ::=
  { iso(1) identified-organization(3) dod(6) internet(1) private(4)
    enterprise(1) snijders(41948) erikpartition(827) }

ErikPartition ::= SEQUENCE {
  version [0]      INTEGER DEFAULT 0,
  partitionTime    GeneralizedTime,
  hashAlg          DigestAlgorithmIdentifier,
  manifestList     SEQUENCE SIZE (1..MAX) OF ManifestRef }

ManifestRef ::= SEQUENCE {
  hash             Digest,
  size             INTEGER (1000..MAX),
  aki              KeyIdentifier,
  manifestNumber   INTEGER (0..MAX),
  thisUpdate       GeneralizedTime,
  location         SEQUENCE SIZE (1..MAX) OF AccessDescription }
END]]>
</sourcecode>

      <section anchor="genstructure">
        <name>General Syntax</name>
        <t>
          The content of an Erik object is an instance of <tt>EncapsulatedContentInfo</tt>.
        </t>
        <section>
          <name>eContentType</name>
          <t>
            The <tt>eContentType</tt> is an OID specifying the type of payload in this object.
          </t>
        </section>
        <section>
          <name>eContent</name>
          <t>
            The eContent is the payload of the Erik object encapsulated in an OCTET STRING.
          </t>
        </section>
      </section>

      <section anchor="asn1-index">
        <name>ErikIndex</name>
        <t>
          An ErikIndex represents all current manifest objects available under a given FQDN and thus the complete state of the repository as it is known to the relay.
        </t>

        <section title="The version field">
          <t>
            The version number of the ErikIndex object <bcp14>MUST</bcp14> be 0.
          </t>
        </section>

        <section title="The indexScope field">
          <t>
            The <tt>indexScope</tt> field contains the fully qualified domain name of the Signed Object location of the manifests referenced through this particular ErikIndex.
            The FQDN MUST be in the "preferred name syntax", as specified by <xref target="RFC1034" section="3.5"/> and modified by <xref target="RFC1123" section="2.1"/>.
          </t>
        </section>

        <section title="The indexTime field">
          <t>
            The <tt>indexTime</tt> is the most recent <tt>partitionTime</tt> value among the ErikPartitions referenced from this ErikIndex.
            The field's value roughly indicates when the ErikIndex was generated and can be used for troubleshooting and measurement purposes.
          </t>
          <t>
            For the purposes of this profile, <tt>GeneralizedTime</tt> values MUST be expressed UTC (Zulu) and MUST include seconds (i.e., times are YYYYMMDDHHMMSSZ), even where the number of seconds is zero.
            GeneralizedTime values MUST NOT include fractional seconds.
            See <xref target="RFC5280" section="4.1.2.5.2"/>.
          </t>
          <t>
            <em>
              Design note: using the most recent <tt>partitionTime</tt>, rather than the local system's notion of "now", helps reduce churn in distributed systems.
            </em>
          </t>
        </section>

        <section title="The hashAlg field">
          <t>
            This field contains the OID of the hash algorithm used to hash the ErikPartitions.
            The hash algorithm used MUST conform to the RPKI Algorithms and Key Size Profile specification <xref target="RFC7935"/>.
          </t>
        </section>

        <section title="The partitionList field">
          <t>
            This field is a sequence of <tt>PartitionRef</tt> instances.
            There is one <tt>PartitionRef</tt> for each current ErikPartition.
            Each <tt>PartitionRef</tt> is a 3-tuple consisting of the partition identifier, the hash of the partition object, and the size of the partition object.
          </t>
          <t>
            Information elements are unique with respect to one another and sorted in ascending order of the partition identifier.
          </t>
        </section>

      </section>

      <section anchor="asn1-partition">
        <name>ErikPartition</name>
        <t>
          An ErikPartition represents a subset of manifest objects available under a given FQDN.
          Each ErikPartition is an ordered listing of the manifest objects' hashes, manifestNumber values, thisUpdate values, and their end-entity certificates' SIA extension values.
        </t>

        <section title="The version field">
          <t>
            The version number of the ErikPartition object <bcp14>MUST</bcp14> be 0.
          </t>
        </section>

        <section title="The partitionTime field">
          <t>
            The <tt>partitionTime</tt> is the most recent <tt>thisUpdate</tt> value among the manifests contained within this ErikPartition.
            The field's value roughly indicates when the ErikPartition was generated and can be used for troubleshooting and measurement purposes.
          </t>
          <t>
            For the purposes of this profile, <tt>GeneralizedTime</tt> values MUST be expressed UTC (Zulu) and MUST include seconds (i.e., times are YYYYMMDDHHMMSSZ), even where the number of seconds is zero.
            GeneralizedTime values MUST NOT include fractional seconds.
            See <xref target="RFC5280" section="4.1.2.5.2"/>.
          </t>
          <t>
            <em>
              Design note: using the most recent manifest <tt>thisUpdate</tt> value, rather than the local system's notion of "now", helps reduce churn in distributed systems.
            </em>
          </t>
        </section>

        <section title="The hashAlg field">
          <t>
            This field contains the OID of the hash algorithm used to hash the manifest objects referenced in this ErikPartition.
            The hash algorithm used MUST conform to the RPKI Algorithms and Key Size Profile specification <xref target="RFC7935"/>.
          </t>
        </section>

        <section title="The manifestList field">
          <t>
            This field is a sequence of <tt>ManifestRef</tt> instances.
            There is one <tt>ManifestRef</tt> for each current manifest.
            A manifest is nominally current until the time specified in nextUpdate or until a manifest is issued with a greater manifestNumber, whichever comes first (see <xref target="RFC9286" section="4.2.1"/>).
          </t>
          <t>
            A <tt>ManifestRef</tt> is a structure consisting of the hash of the manifest object, the size of the manifest object, the manifest issuer's key identifier, the manifestNumber, and the thisUpdate contained within the object, and a sequence of <tt>AccessDescription</tt> instances from the manifest's End-Entity certificate's Subject Information Access extension.
          </t>
          <t>
            Information elements are unique with respect to one another and sorted in ascending order of the hash.
          </t>
        </section>

      </section>
    </section>

<!-- XXX NOTE: it is not clear how to do snapshots or whether it is needed.

    <section anchor="snapshots">
      <name>Snapshots and Differentials</name>
      <t>
        Clients should be able to bootstrap initial state by fetching a snapshot.
        A snapshot contains all RPKI objects a relay associated with a given FQDN as of the time of the snapshot's production.
        Snapshots do not contain ErikIndex or ErikPartition objects.
        Because snapshots are not produced in lockstep with updates to the merkle trees, clients MUST perform a tree comparison after fetching a snapshot.
      </t>
      <t>
        Note: Snapshots encoding is TBD.
      </t>
      <t>
        A compressed form (<xref target="RFC1951"/>, <xref target="RFC1952"/>) should be used because opportunistic compression in the transport layer (e.g. HTTP compressed content-encoding) is not universally available.
      </t>
      <t>
        Fetching differences between snapshots ('deltas') might be specified at a later time, or might be concluded to be unnecessary.
      </t>
      <t>
        <em>
          Design notes:
          While the <xref target="ustar"/> format is 'streamable', widely available, and an open standard, a notable downside is that <tt>.tar.gz</tt> objects likely wont be produced in a deterministic fashion across different implementations, warranting a choice for a bespoke format.
        </em>
      </t>
    </section>
-->

    <section anchor="rp">
      <name>Client-side Processing</name>
      <t>
        Clients start by fetching an <tt>ErikIndex</tt>, which is represents the relay's current Merkle tree head for a given FQDN.
        A client <bcp14>MUST</bcp14> verify the requested FQDN exactly matches the <tt>indexScope</tt> value in the <tt>ErikIndex</tt>, and if not proceed to use a different relay.
      </t>
      <t>
        Then, clients can decide whether or not to fetch <tt>ErikPartition</tt> objects listed on the <tt>ErikIndex</tt>, for instance, by checking whether the object associated with the hash was already fetched at some point in the client's past.
      </t>
      <t>
        Before using a <tt>ErikPartition</tt>, the client <bcp14>MUST</bcp14> verify that all URIs in the accessLocations in the id-ad-signedObject accessMethod instances in the <tt>ErikPartition</tt> are encompassed in the requested <tt>indexScope</tt>.
        A client can then decide whether or not to fetch a given manifest object, by comparing the <tt>manifestNumber</tt> and <tt>thisUpdate</tt> with what's locally cached and what's offered by the remote relay.
      </t>
      <t>
        A client can compute which products listed in the manifest's <tt>fileList</tt> need to be fetched from one relay or another in order to achieve a successful fetch.
        A client <bcp14>MUST</bcp14> verify that the URI in the accessLocation in one of the id-ad-signedObject accessMethod instances in the manifest's Subject Information Access (SIA) is encompassed in the requested <tt>indexScope</tt>.
      </t>
      <t>
        As there is no concept of 'sessions' (like in RRDP), clients can interchangeably use different Erik relays.
        When one Erik relay generates a HTTP error, the client can try fetching the requested object from another Erik relay.
        To improve reliability, clients should alternate among different relays in successive query and fetch attempts.
      </t>
    </section>

    <section anchor="querying">
      <name>Querying an Erik Relay</name>
      <section title="Fetching objects by hash">
        <t>
          This specification uses "Named Information" identifiers mapped to <tt>.well-known</tt> HTTP/HTTPS URLs for object retrieval, as described in <xref target="RFC6920"/>.
        </t>
        <t>
          For example, issuance <tt>#54</tt> of <tt>ripe-ncc-ta.mft</tt> has the following SHA256 digest: <tt>c2d0427bc5a32c42eea1ab5663d592b1fc29c7d4ef16ab0b5e1d631d039dcc21</tt>.
        </t>
        <t>
          To fetch the aforementioned object from an relay hosted at <tt>relay.example.net</tt>, a client would access the following HTTP URL:
          <tt>https://relay.example.net/.well-known/ni/sha-256/wtBCe8WjLELuoatWY9WSsfwpx9TvFqsLXh1jHQOdzCE</tt>
        </t>
      </section>
      <section title="Fetching ErikIndex objects">
        <t>
          The URIs to fetch ErikIndex objects can be constructed using the following Well-Known URI template with the <tt>erik</tt> keyword as suffix and the <tt>FQDN</tt> as parameter: <tt>https://{relay_host}/.well-known/erik/index/{FQDN}</tt>.
        </t>
        <t>
          For example, the URI to fetch an <tt>ErikIndex</tt> for the <tt>rpki.ripe.net</tt> FQDN from a relay at <tt>relay.example.net</tt> would be: <tt>https://relay.example.net/.well-known/erik/index/rpki.ripe.net</tt>.
        </t>
        <t>
          A client <bcp14>MAY</bcp14> use the <tt>If-Modified-Since</tt> HTTP header when fetching <tt>ErikIndex</tt> objects.
        </t>
      </section>
    </section>

    <section anchor="error">
      <name>Transport Error Detection and Handling</name>
      <t>
        The client MUST calculate the hashes of fetched objects and verify they are the same as the expected hashes (which are embedded in the URIs through which the objects were retrieved).
        If there is a hash mismatch, the client may try fetching the object from a different Erik relay or treat this as a <em>failed fetch</em> (see <xref target="RFC9286" section="6.6"/>) and try again at a later point in time in a next validation run.
      </t>
    </section>

    <section anchor="relay">
      <name>Setting Up an Erik Relay</name>
      <t>
        Erik relays can be operated by any party, without permission from or coordination with publication point operators or CAs.
        Relays are made accessible via either HTTP or HTTPS or both.
      </t>
      <t>
        Relays generate and make accessible ErikIndexes and ErikPartitions derived from their current validation state, the client then cherry-picks which objects (if any) it wishes to fetch.
        In turn, relays fetch fresh data from other relays, or from CA-designated publication points accessible via Rsync (<xref target="RFC5781"/>) and RRDP (<xref target="RFC8182"/>).
      </t>
      <t>
        <em>
          Design notes: a decision must be made on a deterministic "manifest-to-partition" assignment scheme.
          Job's proof-of-concept relay (see <xref target="running_code"/>) uses the first few octets of the the Manifest's AKI as a stable partition assignment scheme.
          Other strategies could be to assign manifests to ErikPartitions based on the "hour-of-day" of the CMS signing timestamp, or the first few octets of the SHA-256 of the manifest object.
        </em>
      </t>
    </section>

    <section anchor="comparison">
      <name>Comparison with other RPKI transport protocols</name>

      <t>
        Ignoring obvious mechanical "on the wire" differences between Erik, Rsync, and RRDP; there are a number of concept differences between the protocols.
        Rsync and RRDP can be described as "general purpose" synchronisation protocols: they could be used to transfer any arbitrary set of files, on the other hand the Erik protocol is RPKI-specific: part of its signaling layer are RPKI manifest objects, which RPs require as recourse for validation anyway.
        This property by itself causes a small deduplication in the data to be transferred.
      </t>

      <section>
        <name>Comparison with Rsync</name>
        <t>
          In Rsync, the server and the client construct and transfer a full listing of all available objects, and then transfer objects as necessary.
          In effect, this allows clients to 'jump' to the latest repository state, regardless of the state of the local cache.
        </t>
        <t>
          A major downside of Rsync is that the list of files itself can become a burden to transfer.
          As of June 2025, in order to merely establish whether a client is synchronized or not with the RIPE NCC repository at <tt>rpki.ripe.net</tt>, as much as 5.8 megabytes of data are exchanged without exchanging any RPKI data.
        </t>
        <t>
          Experimentation suggests that when synchronizing once an hour, Erik consumes less network traffic than Rsync generally would consume which, in turn, is less network traffic than RRDP would.
        </t>
      </section>

      <section>
        <name>Comparison with RRDP</name>
        <t>
          The key concept in RRDP is that the client downloads a "journal", containing all add/update/delete operations and replays this journal to arrive at the current repository state.
        </t>
        <t>
          A major downside of RRDP is that (depending on the RRDP polling interval) clients end up downloading data which has become outdated.
          Imagine a hypothetical CA which issues and revokes a ROA every 10 minutes and a client that synchronizes every 60 minutes; in effect the client must fetch 5 outdated states, wasting bandwidth.
        </t>
        <t>
          Experimentation suggests that when synchronizing every 15 minutes, Erik consumes less network traffic than RRDP generally would consume which, in turn, is less network traffic than Rsync would consume.
        </t>

        <section>
          <name>Garbage Collection</name>
          <t>
            In contrast to RRDP, the Erik protocol has no concept of server-specific "stateful" sessions that persist across polling attempts.
            This obviates the need for <tt>withdraw</tt> instructions as part of the protocol exchange: clients can simply delete objects that are no longer referenced from their current validation state and refetch them later on if needed.
          </t>
        </section>

      </section>

    </section>

    <section anchor="openquestions" removeInRFC="true">
      <name>Open Questions</name>
       <ul>
         <li>Which of the possible deterministic manifest-to-partition assignment strategies yield the best results? AKI?</li>
         <li>Are deterministic and cheap Snapshots possible? If so, what is the best archive format for Snapshots? The ustar/gzip combo might not easily yield deterministic results across different implementations.</li>
         <li>Is the concept of Differentials/Deltas needed in Erik Synchronization?</li>
         <li>What will be the upper bound for the number of partitions? (<tt>ub-Partitions</tt>)</li>
       </ul>
    </section>

    <section anchor="operational">
      <name>Operational Considerations</name>
      <section>
        <name>Scaling considerations</name>
        <t>
          As of July 2025, the global Internet's RPKI churn rate appears to be 2 new objects per second.
          The ecosystem is estimated to be composed of ~ 5000 RPKI cache instances and ~ 50 repository servers.
          Assuming 10 minute fetching intervals and 150 metadata requests per synchronization run (for exchange of Merkle tree data), an Erik relay serving all the Internet's RPKI cache instances would probably need to be able to sustain serving an average of at least 11,000 HTTP requests per second.
          This order of magnitude in terms of scaling requirements can easily be handled by a single commodity server.
        </t>
      </section>
      <section>
        <name>HTTP Compression</name>
        <t>
          Using gzip compression on average tends to yield a 20% reduction in RPKI object size, therefore it is <bcp14>RECOMMENDED</bcp14> for clients and relays to offer support for compressed content coding, as described in <xref target="RFC9110" section="8.4.1"/>.
        </t>
        <t>
          Using a previous version of a RPKI object as a compression dictionary for a newer version enables delivery of a delta-compressed version of the changes, usually resulting in significantly smaller responses than what can be achieved by compression alone.
          Clients can facilitate delta compression by sending an <tt>Available-Dictionary</tt> request header, using a previously fetched version of the RPKI object as the dictionary.
          It is <bcp14>RECOMMENDED</bcp14> for clients and relays to make use of Compression Dictionary Transport (<xref target="RFC9842"/>).
        </t>
      </section>
    </section>

    <section anchor="security">
      <name>Security Considerations</name>
      <t>
        This document makes no changes to RPKI certificate validation procedures.
      </t>
      <t>
        Paraphrasing <xref target="RFC6810" section="11"/>:
        The RPKI relies on object, not server or transport, trust.
        That is, the Regional Internet Registry root trust anchors are distributed through some out-of-band means, and can then be used by each relying party to validate certificate chains and Signed Objects.
        The inter-cache relationships are based on this object security model; hence, any cache-to-cache transport is assumed to be unreliable at times.
        See <xref target="RFC8182" section="5"/> for more security considerations.
      </t>
      <t>
        To avoid certain forms of replay attack, clients <bcp14>MUST</bcp14> verify purported <tt>indexScope</tt>, <tt>ManifestRef</tt> location values, and manifest Subject Information Access (SIA) extensions match the expected FQDN.
      </t>
      <t>
        Byzantine events or faults in relay-to-client communication can be overcome by the client rotating requests for objects among different Erik relays.
      </t>
    </section>

    <section anchor="iana">
      <name>IANA Considerations</name>

      <section title="S/MIME Module Identifier">
        <t>
          The IANA is requested to add an item to the "SMI Security for S/MIME Module Identifier" registry as follows:
        </t>
        <artwork>
<![CDATA[
Decimal  Description                          References
----------------------------------------------------------
  TDB    id-mod-rpkiErikSynchronization-2025  [this-draft]
]]>
        </artwork>
      </section>

      <section title="SMI Security for S/MIME CMS Content Type (1.2.840.113549.1.9.16.1)">
        <t>
          The IANA is requested to allocate for this document in the "SMI Security for S/MIME CMS Content Type (1.2.840.113549.1.9.16.1)" registry:
        </t>
        <artwork>
<![CDATA[
Decimal  Description              References
----------------------------------------------
  TBD    id-ct-rpkiErikIndex      [this-draft]
  TBD    id-ct-rpkiErikPartition  [this-draft]
]]>
        </artwork>
        <t>
          Upon publication of this document, IANA is requested to reference the RFC publication instead of this draft.
        </t>
        <t>
          For the current proof-of-concept phase, OIDs for <tt>id-ct-rpkiErikIndex</tt> and <tt>id-ct-rpkiErikPartition</tt> were assigned from a PEN arc.
          Implementers are not expected to make any special accommodations to retain backwards compatibility with these PEN OIDs, after IANA assigns OIDs.
        </t>
      </section>

      <section title="Well-Known URI">
        <t>
          An URI Suffix in the Well-Known URIs registry specific to Erik synchronization will be requested.
          See https://github.com/protocol-registries/well-known-uris/issues/67 for the request.
        </t>
        <t>
          The proposed suffix is <tt>erik</tt>.
        </t>
      </section>

    </section>

  </middle>

  <back>
    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>

        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.1034.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.1123.xml"/>
<!--
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.1951.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.1952.xml"/>
-->
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.5280.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.6810.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.6920.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7935.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.9110.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.9286.xml"/>

        <reference anchor="X.690" target="https://www.itu.int/rec/T-REC-X.690-202102-I/en" quoteTitle="true" derivedAnchor="X.690">
          <front>
            <title>Information technology - ASN.1 encoding rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER)</title>
            <author>
              <organization showOnFrontPage="true">ITU-T</organization>
            </author>
            <date month="February" year="2021"/>
          </front>
          <seriesInfo name="ITU-T Recommendation" value="X.690"/>
          <seriesInfo name="ISO/IEC" value="8825-1:2021"/>
        </reference>

      </references>

      <references>
        <name>Informative References</name>

        <reference anchor="M1987" quoteTitle="true" target="https://doi.org/10.1007/3-540-48184-2_32" derivedAnchor="M1987">
          <front>
            <title>A Digital Signature Based on a Conventional Encryption Function</title>
            <author fullname="R. Merkle" initials="R." surname="Merkle"/>
            <date year="1988"/>
          </front>
          <refcontent>Advances in Cryptology -- CRYPTO '87 Proceedings</refcontent>
          <refcontent>Lecture Notes in Computer Science, Vol. 293</refcontent>
          <seriesInfo name="DOI" value="10.1007/3-540-48184-2_32"/>
        </reference>

        <reference anchor="P2P" target="https://www.ietf.org/proceedings/83/slides/slides-83-sidr-9.pdf">
          <front>
            <title>RPKI Over BitTorrent</title>
            <author fullname="Rob Austein" initials="R." surname="Austein"/>
            <author fullname="Randy Bush" initials="R." surname="Bush"/>
            <author fullname="Michael Elkins" initials="M." surname="Elkins"/>
            <author fullname="Leif Johansson" initials="L." surname="Johansson"/>
            <date year="2012" month="March"/>
          </front>
        </reference>

<!--
        <reference anchor="ustar" target="https://pubs.opengroup.org/onlinepubs/9799919799/utilities/pax.html#tag_20_94_13_06">
          <front>
            <title>ustar Interchange Format</title>
            <author>
              <organization>IEEE/Open Group</organization>
            </author>
            <date year="2024" month="June"/>
          </front>
          <seriesInfo name="IEEE Std" value="1003.1-2024"/>
          <seriesInfo name="DOI" value="10.1109/IEEESTD.2018.8423794"/>
        </reference>
-->

        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.0677.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.1925.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.5781.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.6480.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7115.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8182.xml"/>
        <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.9842.xml"/>

        <reference anchor="rpkitouch" target="https://www.github.com/job/rpkitouch">
          <front>
            <title>rpkitouch</title>
            <author fullname="Job Snijders"/>
            <date month="September" year="2025" />
          </front>
        </reference>
<!--
        <reference anchor="rpki-client" target="https://www.rpki-client.org/">
          <front>
            <title>rpki-client</title>
            <author fullname="Claudio Jeker"/>
            <author fullname="Job Snijders"/>
            <author fullname="Kristaps Dzonsons"/>
            <author fullname="Theo Buehler"/>
            <date month="June" year="2024" />
          </front>
        </reference>
-->

      </references>
    </references>

    <section anchor="running_code" title="Implementation status" removeInRFC="true">
      <t>
        This section records the status of known implementations of the protocol defined by this specification at the time of posting of this Internet-Draft, and is based on a proposal described in RFC 7942.
        The description of implementations in this section is intended to assist the IETF in its decision processes in progressing drafts to RFCs.
        Please note that the listing of any individual implementation here does not imply endorsement by the IETF.
        Furthermore, no effort has been spent to verify the information presented here that was supplied by IETF contributors.
        This is not intended as, and must not be construed to be, a catalog of available implementations or their features.
        Readers are advised to note that other implementations may exist.
      </t>

      <t>
        According to RFC 7942, "this will allow reviewers and working groups to assign due consideration to documents that have the benefit of running code, which may serve as evidence of valuable experimentation and feedback that have made the implemented protocols more mature.
        It is up to the individual working groups to use this information as they see fit".
      </t>
      <t>
        A few experimental Erik relays are available, each running on slightly different schedules.
        Client implementers are encouraged to round-robin between these instances to observe results.
      </t>
      <dl>
        <dt><tt>http://relay.rpki-servers.org/</tt></dt>
        <dd>Dublin, Montreal, Osaka, S&#227;o Paulo, Sydney - anycasted distributed computing cluster</dd>

        <dt><tt>http://dub.rpki-servers.org/</tt></dt>
        <dd>Dublin, Ireland, - distributed computing cluster (6 machines, NFS backend)</dd>

        <dt><tt>http://atl.rpki-servers.org/</tt></dt>
        <dd>Atlanta, USA, - distributed computing cluster (2 machines, NFS backend)</dd>

        <dt><tt>http://miso.sobornost.net/</tt></dt>
        <dd>Amsterdam, NL, single node</dd>

        <dt><tt>http://nyc.rpki-servers.org/</tt></dt>
        <dd>New York, USA, - single node</dd>

        <dt><tt>http://fnllwqoupfrhso6643whm6lpkgsftjtc6crpehmyz2o7pffirnqy7rad.onion/</tt></dt>
        <dd>Erik relay service via Tor</dd>
      </dl>

      <t>
        An experimental Erik static content generator was developed by Job Snijders in the form of <xref target="rpkitouch"/> using <tt>C</tt>.
      </t>

    </section>

    <section anchor="example_payloads">
      <name>Example objects</name>
      <t>
        Included in this section are an <tt>ErikIndex</tt> for <tt>rpki.ripe.net</tt> and an <tt>ErikPartition</tt> referenced from the aforementioned ErikIndex, both Base64 encoded.
      </t>

      <section>
        <name>Example ErikIndex</name>
        <t>
          This object was retrieved from <tt>http://miso.sobornost.net/.well-known/erik/rpki.ripe.net</tt>.
        </t>
        <sourcecode anchor="ex_index" type="base64" src="rpki.ripe.net.b64"/>
      </section>

      <section>
        <name>Example ErikPartition</name>
        <t>
          This object was retrieved from <tt>http://miso.sobornost.net/.well-known/ni/sha-256/c2zSaUVzFAW7XY7BDGXzGvjLR0xlRmo2gD_FuC70mGQ</tt>.
        </t>
        <sourcecode anchor="ex_part" type="base64" src="c2zSaUVzFAW7XY7BDGXzGvjLR0xlRmo2gD_FuC70mGQ.b64"/>
      </section>
    </section>

    <section anchor="acknowledgements" numbered="false">
      <name>Acknowledgements</name>
      <t>
        The authors wish to thank
          <contact fullname="George Michaelson"/>,
          <contact fullname="Theo de Raadt"/>,
          <contact fullname="Bob Beck"/>,
          <contact fullname="Theo Buehler"/>,
          and
          <contact fullname="William McCall"/>
        for the lovely conversations that led to this proposal.
      </t>
      <t>
        This protocol is named after Erik Bais, who passed away in 2024, as a small token of appreciation for his friendship.
      </t>
    </section>

  </back>
</rfc>
